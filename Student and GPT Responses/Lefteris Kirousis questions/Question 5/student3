Three BFS searches should be run, starting from s, t1, and t2, resulting in three trees.
From the tree rooted at s, potential nodes u must be in a level lower (closer to s) than both t1 and t2, because d(s, u) must be less than d(s, t1) and d(s, t2). So, nodes u would be in the level one lower than the lowest level between t1 and t2, to maximize distance from s. This would give d(s, u), based on the level of the identified nodes. From this tree, d(s, t1) and d(s, t2) can also be identified.
Then, from the tree rooted at t1, the previously identified potential nodes u should be checked for their distances from t1, which is the length of the path from t1 to the potential node u in the BFS tree. Only the potential nodes u with d(t1, u) that satisfy the inequality that d(s, u) + d(t1, u) <= d(s, t1) should be kept. We now have a smaller set of nodes as potential nodes u.
From the tree rooted at t2, each potential node u that satisfied the inequality involving d(t1, u) should be checked for its distance from t2, which is the length of the path from t2 to the potential node in this BFS tree. Only the nodes u with d(t2, u) that satisfy the inequality that d(s, u) + d(t2, u) <= d(s, t2) should be kept.
The final resulting set of nodes are valid choices for node u, as they satisfy all  given conditions. One of these nodes should be returned.
The complexity of BFS is O(m) for undirected connected graphs. There are no more than m edges in each resulting tree, so the time to process edges for each tree is at most m, so the total processing time for all three trees would be at most 3m. Given that the graph is connected, m >= n-1, so adding the time to process all nodes, in the worst case, would still result in the algorithm being O(m).

