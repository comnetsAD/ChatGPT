Here is how the algorithm works: Create a BFS tree and begin searching from node s. Start a new BFS from the t1 node. To continue, initiate a third BFS at node t2. Find the node u in the graph with the greatest distance from s, but where the distance from s to t1 through u is less than the distance from s to t2 via u. The O(m) runtime of this method may be broken down into three O(n+m)-time BFS searches and one O(n)-time iteration across all the nodes. The total time complexity is thus O(3(n+m)), or O. (m). 