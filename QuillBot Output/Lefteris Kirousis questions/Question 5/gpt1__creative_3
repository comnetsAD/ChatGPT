Here is how the algorithm works: Start at node s and record the distance that each node is from s using a breadth-first search (BFS). Time complexity here is O(m + n). To find out how far each node is from the starting point, run a second BFS starting at t=t1. In the same way, this process is O(m + n) intensive. Perform a third BFS starting at node t2, keeping track of the distances to all other nodes. Similarly, this process requires O(m + n) time. Then, go through all the nodes and choose the one u that meets these criteria: There is the greatest possible separation between u and s. The shortest route from s to t1 that includes u cannot be longer than the original path between s and t1. In other words, the shortest route from s to t2 that includes u cannot be longer than the original path from s to t2. Send back the u node. Since the method executes three BFS, each of which requires O(m+n) time, the total time required by the algorithm is O(m + n). 