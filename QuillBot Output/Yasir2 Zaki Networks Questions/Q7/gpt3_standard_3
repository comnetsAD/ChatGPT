We must first get the total of the three 8-bit bytes 01010011, 01100110, and 01110100 in order to determine the 1s complement. We may do this by converting each byte into a decimal number and combining them. 01010011 is equal to 1 * 27 + 0 * 26 + 1 * 25 + 0 * 24 + 0 * 23 + 1 * 22 + 0 * 21 + 1 * 20 = 83 in decimal form. 01100110 is equal to 1 * 27, 1 * 26, 0 * 25, and 0 * 22 in decimal form. 4 + 1 * 2^3 + 1 * 2^2 + 0 * 2^ 1 + 1 * 2^0 = 102 01110100 is equal to 1 * 2 * 7 * 1 * 2 * 6 * 1 * 2 * 5 * 1 * 2 in decimal form. 4 + 0 * 2^3 + 1 * 2^2 + 0 * 2^ 1 + 0 * 2^0 = 116 The three bytes add up to 83 + 102 + 116 = 301. We must first determine the 2s complement of the total before we can determine the 1s complement. To do this, all the bits of the sum may be inverted (turning 1s into 0s and 0s into 1s), and 1 can then be added to the result. All of 301's bits are inverted to get the 2s complement: 301 equals 301 times one, or 11101100. The 2s complement of 301 may then be obtained by adding 1 to the result: 11101100 + 1 = 11101101 We can easily flip all the bits in the 2s complement to determine the sum's 1s complement: 11101101 equals 301's 1s complement, or 00010010. The total of the three 8-bit bytes 01010011, 01100110, and 01110100 is thus 00010010, which is the 1s complement. The 1s complement checksum algorithm is used by UDP and TCP because it enables the receiver to quickly identify mistakes. The receiver may recalculate the checksum using the same manner once the transmitter computes it and delivers it with the data. 